

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>demes.demes &mdash; demes  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> demes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../convert.html">Conversion functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">demes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>demes.demes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for demes.demes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">from</span> <span class="nn">attr.validators</span> <span class="kn">import</span> <span class="n">optional</span>

<span class="n">Number</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
<span class="n">ID</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">Time</span> <span class="o">=</span> <span class="n">Number</span>
<span class="n">Size</span> <span class="o">=</span> <span class="n">Number</span>
<span class="n">Rate</span> <span class="o">=</span> <span class="nb">float</span>
<span class="n">Proportion</span> <span class="o">=</span> <span class="nb">float</span>


<span class="c1"># Validator functions.</span>


<span class="k">def</span> <span class="nf">positive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> must be greater than zero&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">non_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> must be non-negative&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">finite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> must be finite&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unit_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;must have 0 &lt;= </span><span class="si">{</span><span class="n">attribute</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &lt;= 1&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">eq_can_be_function</span><span class="p">(</span><span class="n">attrs_cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class decorator for attrs classes that mimics the functionality of the</span>
<span class="sd">    not-yet-merged https://github.com/python-attrs/attrs/pull/627</span>
<span class="sd">    This makes it possible to pass an `eq=some_func` arg to attr.ib(),</span>
<span class="sd">    which will be used when comparing that attribute during object</span>
<span class="sd">    equality tests.</span>

<span class="sd">    TODO: Remove this when the attrs pr makes its way into a release.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare two objects for equality.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__attrs_attrs__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attrib</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">attrib</span><span class="o">.</span><span class="n">eq</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">attrib</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># Bizarrely, nan!=nan but (nan,)==(nan,). We don&#39;t expect to be</span>
                <span class="c1"># doing nan comparisons here, but the latter behaviour matches</span>
                <span class="c1"># attrs (and makes more sense generally).</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">a1</span><span class="p">,)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">a2</span><span class="p">,):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">attrs_cls</span><span class="o">.</span><span class="fm">__eq__</span> <span class="o">=</span> <span class="fm">__eq__</span>
    <span class="k">return</span> <span class="n">attrs_cls</span>


<span class="c1"># Because we overload the ``eq`` parameter to attrib, allowing it to be a</span>
<span class="c1"># callable, mypy complains about the type. So we introduce a wrapper here</span>
<span class="c1"># and tell mypy to ignore the types.</span>
<span class="c1"># TODO: remove this once we remove the ``eq_can_be_function`` decorator.</span>
<span class="k">def</span> <span class="nf">attrib</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrib</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around math.isclose() that handles None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span> <span class="o">==</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
            <span class="n">typing</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">SupportsFloat</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">typing</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">SupportsFloat</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">)</span>


<div class="viewcode-block" id="Epoch"><a class="viewcode-back" href="../../api.html#demes.Epoch">[docs]</a><span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Epoch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Population size parameters for a deme in a specified time period.</span>
<span class="sd">    Times follow the forwards-in-time convention (time values increase</span>
<span class="sd">    from the present towards the past). The start time of the epoch is</span>
<span class="sd">    the more ancient time, and the end time is more recent, so that the</span>
<span class="sd">    start time must be greater than the end time</span>

<span class="sd">    :ivar start_time: The start time of the epoch.</span>
<span class="sd">    :ivar end_time: The end time of the epoch (must be specified).</span>
<span class="sd">    :ivar initial_size: Population size at ``start_time``.</span>
<span class="sd">    :ivar final_size: Population size at ``end_time``.</span>
<span class="sd">        If ``initial_size != final_size``, the population size changes</span>
<span class="sd">        monotonically between the start and end times.</span>
<span class="sd">    :ivar size_function: The size change function. Common options are constant,</span>
<span class="sd">        exponential, or linear, though any string is valid. Warning: downstream</span>
<span class="sd">        simulators might not understand the size_function provided.</span>
<span class="sd">    :ivar selfing_rate: An optional selfing rate for this epoch.</span>
<span class="sd">    :ivar cloning_rate: An optional cloning rate for this epoch.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">(</span><span class="n">non_negative</span><span class="p">),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>
    <span class="n">end_time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>
    <span class="n">initial_size</span><span class="p">:</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">([</span><span class="n">positive</span><span class="p">,</span> <span class="n">finite</span><span class="p">]),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>
    <span class="n">final_size</span><span class="p">:</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">([</span><span class="n">positive</span><span class="p">,</span> <span class="n">finite</span><span class="p">]),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>
    <span class="n">size_function</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">selfing_rate</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">(</span><span class="n">unit_interval</span><span class="p">),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>
    <span class="n">cloning_rate</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">(</span><span class="n">unit_interval</span><span class="p">),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must set either initial_size or final_size&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must have start_time &gt; end_time&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;if start time is inf, must be a constant size epoch&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The time span of the epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span></div>


<div class="viewcode-block" id="Migration"><a class="viewcode-back" href="../../api.html#demes.Migration">[docs]</a><span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Migration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters for continuous migration from one deme to another.</span>
<span class="sd">    Source and destination demes follow the forwards-in-time convention,</span>
<span class="sd">    of migrations born in the source deme having children in the dest</span>
<span class="sd">    deme.</span>

<span class="sd">    :ivar source: The source deme.</span>
<span class="sd">    :ivar dest: The destination deme.</span>
<span class="sd">    :ivar start_time: The time at which the migration rate becomes activate.</span>
<span class="sd">    :ivar end_time: The time at which the migration rate is deactivated.</span>
<span class="sd">    :ivar rate: The rate of migration. Set to zero to disable migrations after</span>
<span class="sd">        the given time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">dest</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">start_time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>
    <span class="n">end_time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>
    <span class="n">rate</span><span class="p">:</span> <span class="n">Rate</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;source and dest cannot be the same deme&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pulse"><a class="viewcode-back" href="../../api.html#demes.Pulse">[docs]</a><span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Pulse</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters for a pulse of migration from one deme to another.</span>
<span class="sd">    Source and destination demes follow the forwards-in-time convention,</span>
<span class="sd">    of migrations born in the source deme having children in the dest</span>
<span class="sd">    deme.</span>

<span class="sd">    :ivar source: The source deme.</span>
<span class="sd">    :ivar dest: The destination deme.</span>
<span class="sd">    :ivar time: The time of migration.</span>
<span class="sd">    :ivar proportion: At the instant after migration, this is the proportion</span>
<span class="sd">        of individuals in the destination deme made up of individuals from</span>
<span class="sd">        the source deme.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">dest</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>
    <span class="n">proportion</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="n">unit_interval</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;source and dest cannot be the same deme&quot;</span><span class="p">)</span></div>


<span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Split</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters for a split event, in which a deme ends at a given time and</span>
<span class="sd">    contributes ancestry to an arbitrary number of descendant demes. Note</span>
<span class="sd">    that there could be just a single descendant deme, in which case ``split``</span>
<span class="sd">    is a bit of a misnomer...</span>

<span class="sd">    :ivar parent: The parental deme.</span>
<span class="sd">    :ivar children: A list of descendant demes.</span>
<span class="sd">    :ivar time: The split time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parent</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;children of split must be passed as a list&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;child and parent cannot be the same deme&quot;</span><span class="p">)</span>


<span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Branch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters for a branch event, where a new deme branches off from a parental</span>
<span class="sd">    deme. The parental deme need not end at that time.</span>

<span class="sd">    :ivar parent: The parental deme.</span>
<span class="sd">    :ivar child: The descendant deme.</span>
<span class="sd">    :ivar time: The branch time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parent</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;child and parent cannot be the same deme&quot;</span><span class="p">)</span>


<span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Merge</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters for a merge event, in which two or more demes end at some time and</span>
<span class="sd">    contribute to a descendant deme.</span>

<span class="sd">    :ivar parents: A list of parental demes.</span>
<span class="sd">    :ivar proportions: A list of ancestry proportions, in order of `parents`.</span>
<span class="sd">    :ivar child: The descendant deme.</span>
<span class="sd">    :ivar time: The merge time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">proportions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Proportion</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parents must be passed as a list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;proportions must be passed as a list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;merge must involve at least two ancestors&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;proportions must sum to 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parents and proportions must have same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;merged deme cannot be its own ancestor&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot repeat parents in merge&quot;</span><span class="p">)</span>


<span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Admix</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters for an admixture event, where two or more demes contribute ancestry</span>
<span class="sd">    to a new deme.</span>

<span class="sd">    :ivar parents: A list of source demes.</span>
<span class="sd">    :ivar proportions: A list of ancestry proportions, in order of `parents`.</span>
<span class="sd">    :ivar child: The admixed deme.</span>
<span class="sd">    :ivar time: The admixture time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">proportions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Proportion</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="p">[</span><span class="n">non_negative</span><span class="p">,</span> <span class="n">finite</span><span class="p">],</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parents must be passed as a list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;proportions must be passed as a list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;admixture must involve at least two ancestors&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Proportions must sum to 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parents and proportions must have same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;admixed deme cannot be its own ancestor&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot repeat parents in admixure&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Deme"><a class="viewcode-back" href="../../api.html#demes.Deme">[docs]</a><span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Deme</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of individuals that are exchangeable at any fixed time.</span>

<span class="sd">    :ivar id: A string identifier for the deme.</span>
<span class="sd">    :ivar description: An optional description of the deme.</span>
<span class="sd">    :ivar ancestors: List of ancestors to the deme.</span>
<span class="sd">        If the deme has no ancestors, this should be ``None``, and cannot</span>
<span class="sd">        be used with ``ancestor``.</span>
<span class="sd">    :ivar proportions: List of proportions if ``ancestors`` is given.</span>
<span class="sd">    :ivar epochs: A list of epochs, which define the population size(s) of</span>
<span class="sd">        the deme. The deme must be initially created with exactly one epoch.</span>
<span class="sd">        Additional epochs may be added with :meth:`.add_epoch`</span>
<span class="sd">    :vartype epochs: list of :class:`.Epoch`</span>
<span class="sd">    :ivar selfing_rate: An optional selfing rate for this deme.</span>
<span class="sd">    :ivar cloning_rate: An optional cloning rate for this deme.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">id</span><span class="p">:</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">ancestors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">proportions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Proportion</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">epochs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">selfing_rate</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">([</span><span class="n">unit_interval</span><span class="p">]),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>
    <span class="n">cloning_rate</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">([</span><span class="n">unit_interval</span><span class="p">]),</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span>
    <span class="p">)</span>

    <span class="nd">@epochs</span><span class="o">.</span><span class="n">validator</span>
    <span class="k">def</span> <span class="nf">_check_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Deme must be created with exactly one epoch.&quot;</span>
                <span class="s2">&quot;Use add_epoch() to supply additional epochs.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ancestors must be a list of deme IDs&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;proportions must be set if more than one ancestor&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportions</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ancestors and proportions must have same length&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> cannot be its own ancestor&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Deme.add_epoch"><a class="viewcode-back" href="../../api.html#demes.Deme.add_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">add_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">:</span> <span class="n">Epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an epoch to the deme&#39;s epoch list.</span>
<span class="sd">        Epochs must be non overlapping and added in time-decreasing order, i.e.</span>
<span class="sd">        starting with the most ancient epoch and adding epochs sequentially toward</span>
<span class="sd">        present.</span>

<span class="sd">        :param .Epoch epoch: The epoch to add.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># if the epoch start time is not given, it equals the previous epoch&#39;s end time</span>
        <span class="n">prev_epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">prev_epoch</span><span class="o">.</span><span class="n">end_time</span>
        <span class="k">elif</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">prev_epoch</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;epochs must be non overlapping and added in time-decreasing order&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">prev_epoch</span><span class="o">.</span><span class="n">end_time</span> <span class="o">!=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot have gap between consecutive epochs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">time_span</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;epoch must exist for some positive time&quot;</span><span class="p">)</span>
        <span class="c1"># implicitly set the initial and final sizes, if not given</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="n">prev_epoch</span><span class="o">.</span><span class="n">final_size</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">final_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span><span class="o">.</span><span class="n">final_size</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span>
        <span class="c1"># check or assign the size function over this epoch</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">==</span> <span class="n">epoch</span><span class="o">.</span><span class="n">final_size</span><span class="p">:</span>
                <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span> <span class="o">=</span> <span class="s2">&quot;exponential&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check if constant function is correct</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span>
                <span class="ow">and</span> <span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">!=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">final_size</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;epoch size function is constant but initial and &quot;</span>
                    <span class="s2">&quot;final sizes are not equal&quot;</span>
                <span class="p">)</span>
        <span class="c1"># if selfing or cloning rates are not given, set them to deme&#39;s default rate</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The start time of the deme&#39;s existence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The end time of the deme&#39;s existence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The time span over which the deme exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span></div>


<div class="viewcode-block" id="DemeGraph"><a class="viewcode-back" href="../../api.html#demes.DemeGraph">[docs]</a><span class="nd">@eq_can_be_function</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DemeGraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A directed graph that describes a demography. Vertices are demes and edges</span>
<span class="sd">    correspond to ancestor/descendent relations. Edges are directed from</span>
<span class="sd">    ancestors to descendants.</span>

<span class="sd">    :ivar description: A human readable description of the demography.</span>
<span class="sd">    :ivar time_units: The units of time used for the demography. This is</span>
<span class="sd">        commonly ``years`` or ``generations``, but can be any string.</span>
<span class="sd">        This field is intended to be useful for documenting a demography,</span>
<span class="sd">        but the actual value provided here should not be relied upon.</span>
<span class="sd">    :ivar generation_time: The generation time of demes, in units given</span>
<span class="sd">        by the ``time_units`` parameter. Concretely, dividing all times</span>
<span class="sd">        by ``generation_time`` will convert the deme graph to have time</span>
<span class="sd">        units in generations.  If ``generation_time`` is ``None``, the units</span>
<span class="sd">        are assumed to be in generations already.</span>
<span class="sd">        See also: :meth:`.in_generations`.</span>
<span class="sd">    :ivar default_Ne: The default population size to use when creating new</span>
<span class="sd">        demes with :meth:`.deme`. May be ``None``.</span>
<span class="sd">    :ivar doi: If the deme graph describes a published demography, the DOI</span>
<span class="sd">        should be be given here. May be ``None``.</span>
<span class="sd">    :ivar demes: A list of demes in the demography.</span>
<span class="sd">        Not intended to be passed when the deme graph is instantiated.</span>
<span class="sd">        Use :meth:`.deme` instead.</span>
<span class="sd">    :vartype demes: list of :class:`.Deme`</span>
<span class="sd">    :ivar migrations: A list of continuous migrations for the demography.</span>
<span class="sd">        Not intended to be passed when the deme graph is instantiated.</span>
<span class="sd">        Use :meth:`migration` or :meth:`symmetric_migration` instead.</span>
<span class="sd">    :vartype migrations: list of :class:`.Migration`</span>
<span class="sd">    :ivar pulses: A list of migration pulses for the demography.</span>
<span class="sd">        Not intended to be passed when the deme graph is instantiated.</span>
<span class="sd">        Use :meth:`pulse` instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sorted_eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># Order-agnostic equality check.</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">time_units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">generation_time</span><span class="p">:</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">([</span><span class="n">positive</span><span class="p">,</span> <span class="n">finite</span><span class="p">]))</span>
    <span class="n">default_Ne</span><span class="p">:</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">optional</span><span class="p">([</span><span class="n">positive</span><span class="p">,</span> <span class="n">finite</span><span class="p">]))</span>
    <span class="n">doi</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">demes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Deme</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">sorted_eq</span><span class="p">)</span>
    <span class="n">migrations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Migration</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">sorted_eq</span><span class="p">)</span>
    <span class="n">pulses</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Pulse</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">sorted_eq</span><span class="p">)</span>
    <span class="n">splits</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Split</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">branches</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mergers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Merge</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">admixtures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Admix</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">selfing_rate</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>
    <span class="n">cloning_rate</span><span class="p">:</span> <span class="n">Proportion</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deme_map</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">ID</span><span class="p">,</span> <span class="n">Deme</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deme_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :class:`.Deme` with the specified id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deme_map</span><span class="p">[</span><span class="n">deme_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deme_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the deme graph contains a deme with the specified id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deme_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deme_map</span>

<div class="viewcode-block" id="DemeGraph.deme"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.deme">[docs]</a>    <span class="k">def</span> <span class="nf">deme</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ancestors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">proportions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">initial_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">final_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epochs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">selfing_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cloning_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a deme to the graph.</span>

<span class="sd">        :param str id: A string identifier for the deme.</span>
<span class="sd">        :param list ancestors: A list of ancestors of this deme. May be ``None``.</span>
<span class="sd">            If ``len(ancestors) &gt; 1``, must also give ``proportions``.</span>
<span class="sd">        :param list proportions: A list of proportions of ancestory for ``ancestors``.</span>
<span class="sd">            Proportions must sum to 1.</span>
<span class="sd">        :param start_time: The time at which this deme begins existing.</span>
<span class="sd">        :param end_time: The time at which this deme stops existing.</span>
<span class="sd">            If the deme has an ancestor the ``end_time`` will be set to the</span>
<span class="sd">            ancestor&#39;s ``start_time``.</span>
<span class="sd">        :param initial_size: The initial population size of the deme. If ``None``,</span>
<span class="sd">            this is taken from the deme graph&#39;s ``default_Ne`` field.</span>
<span class="sd">        :param final_size: The final population size of the deme. If ``None``,</span>
<span class="sd">            the deme has a constant ``initial_size`` population size.</span>
<span class="sd">        :param epochs: Additional epochs that define population size changes for</span>
<span class="sd">            the deme.</span>
<span class="sd">        :ivar selfing_rate: An optional selfing rate for this deme.</span>
<span class="sd">        :ivar cloning_rate: An optional cloning rate for this deme.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_Ne</span>
        <span class="k">if</span> <span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">epochs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_size</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_size</span>
        <span class="k">if</span> <span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;must set initial_size for </span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">selfing_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selfing_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span>
        <span class="k">if</span> <span class="n">cloning_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cloning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span>
        <span class="c1"># set the start time to inf or to the ancestors end times, if not given</span>
        <span class="k">if</span> <span class="n">ancestors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ancestors must be a list of deme IDs&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must specify start time if more than one ancestor&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ancestors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ancestors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancestors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">proportions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">proportions</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="c1"># build the deme, and then add epochs as necessary</span>
        <span class="k">if</span> <span class="n">epochs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if epochs are not given, we assign a single epoch over that deme</span>
            <span class="k">if</span> <span class="n">final_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">final_size</span> <span class="o">=</span> <span class="n">initial_size</span>
            <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">initial_size</span> <span class="o">==</span> <span class="n">final_size</span><span class="p">:</span>
                <span class="n">size_function</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">size_function</span> <span class="o">=</span> <span class="s2">&quot;exponential&quot;</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="n">Epoch</span><span class="p">(</span>
                <span class="n">start_time</span><span class="p">,</span>
                <span class="n">end_time</span><span class="p">,</span>
                <span class="n">initial_size</span><span class="o">=</span><span class="n">initial_size</span><span class="p">,</span>
                <span class="n">final_size</span><span class="o">=</span><span class="n">final_size</span><span class="p">,</span>
                <span class="n">size_function</span><span class="o">=</span><span class="n">size_function</span><span class="p">,</span>
                <span class="n">selfing_rate</span><span class="o">=</span><span class="n">selfing_rate</span><span class="p">,</span>
                <span class="n">cloning_rate</span><span class="o">=</span><span class="n">cloning_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">deme</span> <span class="o">=</span> <span class="n">Deme</span><span class="p">(</span>
                <span class="nb">id</span><span class="p">,</span>
                <span class="n">description</span><span class="p">,</span>
                <span class="n">ancestors</span><span class="p">,</span>
                <span class="n">proportions</span><span class="p">,</span>
                <span class="p">[</span><span class="n">epoch</span><span class="p">],</span>
                <span class="n">selfing_rate</span><span class="p">,</span>
                <span class="n">cloning_rate</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
            <span class="k">if</span> <span class="n">end_time</span> <span class="o">!=</span> <span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;deme and final epoch end times do not align&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="o">=</span> <span class="n">selfing_rate</span>
            <span class="k">if</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="o">=</span> <span class="n">cloning_rate</span>
            <span class="c1"># deal with first epoch and deme start times</span>
            <span class="k">if</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># first epoch starts at deme start time</span>
                <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">start_time</span>
            <span class="k">elif</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">start_time</span><span class="p">:</span>
                <span class="c1"># insert const size epoch to reach the start of first listed epoch</span>
                <span class="n">epochs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">Epoch</span><span class="p">(</span>
                        <span class="n">start_time</span><span class="p">,</span>
                        <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span>
                        <span class="n">initial_size</span><span class="o">=</span><span class="n">initial_size</span><span class="p">,</span>
                        <span class="n">final_size</span><span class="o">=</span><span class="n">initial_size</span><span class="p">,</span>
                        <span class="n">size_function</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                        <span class="n">selfing_rate</span><span class="o">=</span><span class="n">selfing_rate</span><span class="p">,</span>
                        <span class="n">cloning_rate</span><span class="o">=</span><span class="n">cloning_rate</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">start_time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;first epoch start time must be less than or equal to &quot;</span>
                    <span class="s2">&quot;deme start time&quot;</span>
                <span class="p">)</span>
            <span class="c1"># set up sizes of first deme, since subsequent demes are built off of it</span>
            <span class="k">if</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_size</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_size</span>
            <span class="k">if</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">==</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_size</span><span class="p">:</span>
                    <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size_function</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size_function</span> <span class="o">=</span> <span class="s2">&quot;exponential&quot;</span>
            <span class="n">deme</span> <span class="o">=</span> <span class="n">Deme</span><span class="p">(</span>
                <span class="nb">id</span><span class="p">,</span>
                <span class="n">description</span><span class="p">,</span>
                <span class="n">ancestors</span><span class="p">,</span>
                <span class="n">proportions</span><span class="p">,</span>
                <span class="p">[</span><span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">selfing_rate</span><span class="p">,</span>
                <span class="n">cloning_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">deme</span><span class="o">.</span><span class="n">add_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ancestors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proportions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancestors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">proportions</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deme_map</span><span class="p">[</span><span class="n">deme</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">deme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deme</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">check_time_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deme1</span><span class="p">,</span> <span class="n">deme2</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="n">deme1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">deme1</span><span class="p">]</span>
        <span class="n">deme2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">deme2</span><span class="p">]</span>
        <span class="n">time_lo</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">deme1</span><span class="o">.</span><span class="n">end_time</span><span class="p">,</span> <span class="n">deme2</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
        <span class="n">time_hi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">deme1</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">deme2</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">time_lo</span> <span class="o">&lt;=</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="n">time_hi</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2"> not in interval [</span><span class="si">{</span><span class="n">time_lo</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">time_hi</span><span class="si">}</span><span class="s2">], &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;as defined by the time-intersection of </span><span class="si">{</span><span class="n">deme1</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(start_time=</span><span class="si">{</span><span class="n">deme1</span><span class="o">.</span><span class="n">start_time</span><span class="si">}</span><span class="s2">, end_time=</span><span class="si">{</span><span class="n">deme1</span><span class="o">.</span><span class="n">end_time</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="n">deme2</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> (start_time=</span><span class="si">{</span><span class="n">deme2</span><span class="o">.</span><span class="n">start_time</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;end_time=</span><span class="si">{</span><span class="n">deme2</span><span class="o">.</span><span class="n">end_time</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">time_lo</span><span class="p">,</span> <span class="n">time_hi</span>

<div class="viewcode-block" id="DemeGraph.symmetric_migration"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.symmetric_migration">[docs]</a>    <span class="k">def</span> <span class="nf">symmetric_migration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">demes</span><span class="o">=</span><span class="p">[],</span> <span class="n">rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add continuous symmetric migrations between all pairs of demes in a list.</span>

<span class="sd">        :param demes: list of deme IDs. Migration is symmetric between all</span>
<span class="sd">            pairs of demes in this list.</span>
<span class="sd">        :param rate: The rate of migration per generation.</span>
<span class="sd">        :param start_time: The time at which the migration rate is enabled.</span>
<span class="sd">        :param end_time: The time at which the migration rate is disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">demes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must specify two or more demes&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">demes</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">migration</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span></div>

<div class="viewcode-block" id="DemeGraph.migration"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.migration">[docs]</a>    <span class="k">def</span> <span class="nf">migration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add continuous migration from one deme to another.</span>
<span class="sd">        Source and destination demes follow the forwards-in-time convention,</span>
<span class="sd">        so that the migration rate refers to the movement of individuals from</span>
<span class="sd">        the ``source`` deme to the ``dest`` deme.</span>

<span class="sd">        :param source: The source deme.</span>
<span class="sd">        :param dest: The destination deme.</span>
<span class="sd">        :param rate: The rate of migration per generation.</span>
<span class="sd">        :param start_time: The time at which the migration rate is enabled.</span>
<span class="sd">            If ``None``, the start time is defined by the earliest time at</span>
<span class="sd">            which the demes coexist.</span>
<span class="sd">        :param end_time: The time at which the migration rate is disabled.</span>
<span class="sd">            If ``None``, the end time is defined by the latest time at which</span>
<span class="sd">            the demes coexist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">deme_id</span> <span class="ow">in</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">deme_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deme_id</span><span class="si">}</span><span class="s2"> not in deme graph&quot;</span><span class="p">)</span>
        <span class="n">time_lo</span><span class="p">,</span> <span class="n">time_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_time_intersection</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">start_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time_hi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_time_intersection</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">start_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">time_lo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_time_intersection</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Migration</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">rate</span><span class="p">))</span></div>

<div class="viewcode-block" id="DemeGraph.pulse"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.pulse">[docs]</a>    <span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a pulse of migration at a fixed time.</span>
<span class="sd">        Source and destination demes follow the forwards-in-time convention.</span>

<span class="sd">        :param source: The source deme.</span>
<span class="sd">        :param dest: The destination deme.</span>
<span class="sd">        :param proportion: At the instant after migration, this is the expected</span>
<span class="sd">            proportion of individuals in the destination deme made up of individuals</span>
<span class="sd">            from the source deme.</span>
<span class="sd">        :param time: The time at which migrations occur.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">deme_id</span> <span class="ow">in</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">deme_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">deme_id</span><span class="si">}</span><span class="s2"> not in deme graph&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_time_intersection</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pulse</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">proportion</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">successors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lists of successors for all demes in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use collections.defaultdict(list)</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">deme_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
            <span class="n">succ</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">deme_info</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">deme_info</span><span class="o">.</span><span class="n">ancestors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">deme_info</span><span class="o">.</span><span class="n">ancestors</span><span class="p">:</span>
                    <span class="n">succ</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[])</span>
                    <span class="n">succ</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deme_info</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">succ</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predecessors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lists of predecessors (ancestors) for all demes in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">deme_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
            <span class="n">pred</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">deme_info</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">deme_info</span><span class="o">.</span><span class="n">ancestors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">deme_info</span><span class="o">.</span><span class="n">ancestors</span><span class="p">:</span>
                    <span class="n">pred</span><span class="p">[</span><span class="n">deme_info</span><span class="o">.</span><span class="n">id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred</span>

<div class="viewcode-block" id="DemeGraph.split"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add split event at a given time. Split events involve a parental deme</span>
<span class="sd">        whose end time equals the start time of all children demes.</span>

<span class="sd">        :param parent: The ancestral deme.</span>
<span class="sd">        :param children: A list of descendant demes.</span>
<span class="sd">        :param time: The time at which split occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="c1"># check parent/children relationship and end/start times</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">parent</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot be ancestor of own deme&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2"> must have matching end and start times&quot;</span>
                <span class="p">)</span>
            <span class="c1"># the ancestor of each child population is set</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">ancestors</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Split</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span></div>

<div class="viewcode-block" id="DemeGraph.branch"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.branch">[docs]</a>    <span class="k">def</span> <span class="nf">branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add branch event at a given time.</span>

<span class="sd">        :param parent: The ancestral deme.</span>
<span class="sd">        :param children: A list of descendant demes.</span>
<span class="sd">        :param time: The time at which branch event occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2"> start time must be within </span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> time interval&quot;</span>
            <span class="p">)</span>
        <span class="c1"># set the ancestor of the child population</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">ancestors</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Branch</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span></div>

<div class="viewcode-block" id="DemeGraph.merge"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add merger event at a given time, where multiple parents contribute to</span>
<span class="sd">        a descendant deme, and the parent demes cease to exist at that time.</span>

<span class="sd">        :param parents: The ancestral demes.</span>
<span class="sd">        :param proportions: Proportions of ancestral demes contributing to descendant.</span>
<span class="sd">        :param children: The descendant deme.</span>
<span class="sd">        :param time: The time at which merger occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="n">time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2">&#39;s start time must equal admixture time of </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># for parental populations, we check that their end time is &lt;= merge time</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&gt;</span> <span class="n">time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;deme </span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> has end time earlier than </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># if any parent end times are more recent than merge time, we adjust the end</span>
        <span class="c1"># and remove epochs that extend beyond that merger time</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">:</span>
                <span class="k">while</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="c1"># set the ancestors and proportions of the child deme</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">ancestors</span> <span class="o">=</span> <span class="n">parents</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">proportions</span> <span class="o">=</span> <span class="n">proportions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mergers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Merge</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span></div>

<div class="viewcode-block" id="DemeGraph.admix"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.admix">[docs]</a>    <span class="k">def</span> <span class="nf">admix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add admixture event at a given time, where multiple parents contribute to</span>
<span class="sd">        a descendant deme, and the parent demes continue to exist beyond that time.</span>

<span class="sd">        :param parents: The ancestral demes.</span>
<span class="sd">        :param proportions: Proportions of ancestral demes contributing to descendant.</span>
<span class="sd">        :param children: The descendant deme.</span>
<span class="sd">        :param time: The time at which admixture occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="n">time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2">&#39;s start time must equal admixture time of </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># for parental populations, we check that their end time is &lt;= admixture time</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&gt;</span> <span class="n">time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;deme </span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> has end time earlier than </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># set the ancestors and proportions of the child deme</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">ancestors</span> <span class="o">=</span> <span class="n">parents</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">proportions</span> <span class="o">=</span> <span class="n">proportions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">admixtures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Admix</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span></div>

<div class="viewcode-block" id="DemeGraph.get_demographic_events"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.get_demographic_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_demographic_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop through successors/predecessors to add splits, branches, mergers,</span>
<span class="sd">        and admixtures to the deme graph. If a deme has more than one predecessor,</span>
<span class="sd">        then it is a merger or an admixture event, which we differentiate by end and</span>
<span class="sd">        start times of those demes. If a deme has a single predecessor, we check</span>
<span class="sd">        whether it is a branch (start time != predecessor&#39;s end time), or split.</span>

<span class="sd">        This is only used when we build a demography from a YAML file, since it</span>
<span class="sd">        uses the successors/predecessors that are determined by ancestor relationships.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">splits_to_add</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
                    <span class="n">splits_to_add</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">set</span><span class="p">())</span>
                    <span class="n">splits_to_add</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">branch</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_aligned</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">deme_from</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="n">deme_from</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
                        <span class="n">time_aligned</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">time_aligned</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">ancestors</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">admix</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">ancestors</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">proportions</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                    <span class="p">)</span>
        <span class="k">for</span> <span class="n">deme_from</span><span class="p">,</span> <span class="n">demes_to</span> <span class="ow">in</span> <span class="n">splits_to_add</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deme_from</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">demes_to</span><span class="p">),</span> <span class="bp">self</span><span class="p">[</span><span class="n">deme_from</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>

        <span class="c1"># validate demography by checking that times align and there are no migration</span>
        <span class="c1"># or pulse events that fall outside of the time intervals of the demes involved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_demography</span><span class="p">()</span></div>

<div class="viewcode-block" id="DemeGraph.validate_demography"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.validate_demography">[docs]</a>    <span class="k">def</span> <span class="nf">validate_demography</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure that migration, pulse, and end times align.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">migration</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">migration</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                <span class="ow">or</span> <span class="n">migration</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Migration between </span><span class="si">{</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;starts before both demes exist.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">migration</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                <span class="ow">or</span> <span class="n">migration</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Migration between </span><span class="si">{</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;ends after time both demes exist.&quot;</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulses</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">pulse</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                <span class="ow">or</span> <span class="n">pulse</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">dest</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                <span class="ow">or</span> <span class="n">pulse</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
                <span class="ow">or</span> <span class="n">pulse</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">dest</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Pulse from </span><span class="si">{</span><span class="n">pulse</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">pulse</span><span class="o">.</span><span class="n">dest</span><span class="si">}</span><span class="s2"> falls outside of &quot;</span>
                    <span class="s2">&quot;time that both demes exist.&quot;</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="DemeGraph.in_generations"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.in_generations">[docs]</a>    <span class="k">def</span> <span class="nf">in_generations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the demes graph with times in units of generations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deme_graph</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">deme_graph</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="s2">&quot;generations&quot;</span>
        <span class="n">generation_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation_time</span>
        <span class="k">if</span> <span class="n">generation_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deme_graph</span><span class="o">.</span><span class="n">generation_time</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="n">deme_graph</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">deme</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span>
                    <span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span> <span class="o">/=</span> <span class="n">generation_time</span>
                    <span class="n">epoch</span><span class="o">.</span><span class="n">end_time</span> <span class="o">/=</span> <span class="n">generation_time</span>
            <span class="k">for</span> <span class="n">migration</span> <span class="ow">in</span> <span class="n">deme_graph</span><span class="o">.</span><span class="n">migrations</span><span class="p">:</span>
                <span class="n">migration</span><span class="o">.</span><span class="n">start_time</span> <span class="o">/=</span> <span class="n">generation_time</span>
                <span class="n">migration</span><span class="o">.</span><span class="n">end_time</span> <span class="o">/=</span> <span class="n">generation_time</span>
            <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">deme_graph</span><span class="o">.</span><span class="n">pulses</span><span class="p">:</span>
                <span class="n">pulse</span><span class="o">.</span><span class="n">time</span> <span class="o">/=</span> <span class="n">generation_time</span>
            <span class="n">deme_graph</span><span class="o">.</span><span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">deme_graph</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">deme_graph</span><span class="o">.</span><span class="n">mergers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">deme_graph</span><span class="o">.</span><span class="n">admixtures</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">deme_graph</span><span class="o">.</span><span class="n">get_demographic_events</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">deme_graph</span></div>

<div class="viewcode-block" id="DemeGraph.asdict"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.asdict">[docs]</a>    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict representation of the deme graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="DemeGraph.asdict_compact"><a class="viewcode-back" href="../../api.html#demes.DemeGraph.asdict_compact">[docs]</a>    <span class="k">def</span> <span class="nf">asdict_compact</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict representation of the deme graph, with default and</span>
<span class="sd">        implicit values removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="n">time_units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_units</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generation_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">generation_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">doi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_Ne</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default_Ne</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_Ne</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">selfing_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cloning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">demes</span><span class="o">=</span><span class="nb">dict</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">demes</span><span class="p">:</span>
            <span class="n">deme_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="c1"># add ancestors to deme if not None</span>
            <span class="k">if</span> <span class="n">deme</span><span class="o">.</span><span class="n">ancestors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ancestors</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">proportions</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">proportions</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">deme</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">deme</span><span class="o">.</span><span class="n">ancestors</span><span class="p">]):</span>
                    <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># corner case of no ancestors but finite start time</span>
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">start_time</span><span class="p">):</span>
                    <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
            <span class="c1"># add selfing and cloning rates, if not None</span>
            <span class="k">if</span> <span class="n">deme</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">deme</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span>
                <span class="p">):</span>
                    <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">selfing_rate</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">deme</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">deme</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span>
                <span class="p">):</span>
                    <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cloning_rate</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">epochs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">e_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">deme</span><span class="o">.</span><span class="n">epochs</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="c1"># end time required for epochs</span>
                <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
                <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">initial_size</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">final_size</span> <span class="o">!=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">initial_size</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">final_size</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">final_size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;exponential&quot;</span><span class="p">]:</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">size_function</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">size_function</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">deme</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="o">!=</span> <span class="n">deme</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">:</span>
                            <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">selfing_rate</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">:</span>
                            <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">selfing_rate</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">selfing_rate</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">selfing_rate</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">deme</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="o">!=</span> <span class="n">deme</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">:</span>
                            <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cloning_rate</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">:</span>
                            <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cloning_rate</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cloning_rate</span><span class="o">=</span><span class="n">epoch</span><span class="o">.</span><span class="n">cloning_rate</span><span class="p">)</span>
                <span class="n">e_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if more than one epoch, list all epochs</span>
                <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">e_list</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if a single epoch, don&#39;t list as under epochs</span>
                <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">initial_size</span><span class="o">=</span><span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;initial_size&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;final_size&quot;</span> <span class="ow">in</span> <span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;final_size&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;initial_size&quot;</span><span class="p">]:</span>
                        <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">final_size</span><span class="o">=</span><span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;final_size&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="n">e_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;end_time&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">deme</span><span class="o">.</span><span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">deme_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="n">deme</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;demes&quot;</span><span class="p">][</span><span class="n">deme</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">deme_dict</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">m_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">migration</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">:</span>
                <span class="n">m_dict</span><span class="p">[(</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">migration</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">time_lo</span><span class="p">,</span> <span class="n">time_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_time_intersection</span><span class="p">(</span>
                    <span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">migration</span><span class="o">.</span><span class="n">end_time</span> <span class="o">!=</span> <span class="n">time_lo</span><span class="p">:</span>
                    <span class="n">m_dict</span><span class="p">[(</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="n">end_time</span><span class="o">=</span><span class="n">migration</span><span class="o">.</span><span class="n">end_time</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">migration</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="n">time_hi</span><span class="p">:</span>
                    <span class="n">m_dict</span><span class="p">[(</span><span class="n">migration</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">migration</span><span class="o">.</span><span class="n">dest</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="n">start_time</span><span class="o">=</span><span class="n">migration</span><span class="o">.</span><span class="n">start_time</span>
                    <span class="p">)</span>
            <span class="c1"># collapse into symmetric and asymmetric migrations</span>
            <span class="n">m_symmetric</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">m_asymmetric</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">),</span> <span class="n">m_list</span> <span class="ow">in</span> <span class="n">m_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># check if there is equal, reverse migration over the same epoch</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="ow">in</span> <span class="n">m_dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_list</span><span class="p">:</span>
                        <span class="n">no_symmetry</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_compare</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m_dict</span><span class="p">[(</span><span class="n">dest</span><span class="p">,</span> <span class="n">source</span><span class="p">)]):</span>
                            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">m_compare</span><span class="p">:</span>
                                <span class="n">m_symmetric</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="nb">dict</span><span class="p">(</span><span class="n">demes</span><span class="o">=</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">],</span> <span class="n">rate</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">])</span>
                                <span class="p">)</span>
                                <span class="k">if</span> <span class="s2">&quot;start_time&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                                    <span class="n">m_symmetric</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span>
                                <span class="k">if</span> <span class="s2">&quot;end_time&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                                    <span class="n">m_symmetric</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span>
                                <span class="c1"># pop the m_compare so we don&#39;t repeat it</span>
                                <span class="n">m_dict</span><span class="p">[(</span><span class="n">dest</span><span class="p">,</span> <span class="n">source</span><span class="p">)]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m_compare</span><span class="p">)</span>
                                <span class="n">no_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">break</span>
                        <span class="k">if</span> <span class="n">no_symmetry</span><span class="p">:</span>
                            <span class="n">m_asymmetric</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">])</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="s2">&quot;start_time&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                                <span class="n">m_asymmetric</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span>
                            <span class="k">if</span> <span class="s2">&quot;end_time&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                                <span class="n">m_asymmetric</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># all ms in m_list are asymmetric</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_list</span><span class="p">:</span>
                        <span class="n">m_asymmetric</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">])</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="s2">&quot;start_time&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                            <span class="n">m_asymmetric</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="s2">&quot;end_time&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                            <span class="n">m_asymmetric</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;end_time&quot;</span><span class="p">]</span>
            <span class="n">migrations_out</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_symmetric</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">migrations_out</span><span class="p">[</span><span class="s2">&quot;symmetric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_symmetric</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_asymmetric</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">migrations_out</span><span class="p">[</span><span class="s2">&quot;asymmetric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_asymmetric</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">migrations_out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">migrations</span><span class="o">=</span><span class="n">migrations_out</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pulses</span><span class="o">=</span><span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">pulse</span><span class="p">)</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulses</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, PopSim Consortium

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>